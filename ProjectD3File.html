<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <!-- add title -->
    
    <!-- import required libraries here -->
    <!-- <script type="text/javascript" src="../lib/d3.v5.min.js"></script> -->
    <script type="text/javascript" src="../lib/d3.v5.min.js"></script>
    <script type="text/javascript" src="../lib/topojson.v2.min.js"></script>
    <script type="text/javascript" src="../lib/d3-legend.min.js"></script>
    <script type="text/javascript" src="../lib/d3-tip.min.js"></script>
    <script type="text/javascript" src="../lib/d3-geo-projection.v2.min.js"></script>
    
    <style>
        /* define CSS rules here */
        #gameDropdown {
            margin-bottom: 20px;
            margin-right: 35px;
            padding-left: 3px;
        }

        #choropleth {
            fill: #5A5A5A;
            stroke: black;
        }

        .legendQuant {
            font-size: 12px;
            font-family: sans-serif;
        }

        #tooltip {
            position: absolute;
            width: 160px;
            padding: 5px 5px;
            border-radius: 4px;
            font-family: 'Nunito';
            text-align: left;
            color: #fff;
            background-color: rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

    
    </style>

    <title></title>
</head>


<body>
    <!-- Add heading for the visualization -->
    <h1>Global Game Ratings</h1>
    
    <!-- Create dropdown element here. Options should be added after reading in game file, they should not be created here.-->
    <select id="gameDropdown"></select>
    
    <!-- append visualization svg to this div-->
    <!-- <div id="choropleth"></div> -->
    <div id="tooltip"></div>

    <script>    
        // enter code to define margin and dimensions for svg
        var width = 1400;
            height = 700;
            margin = 5;
            padding = 5;
            adj = 180;

        // enter code to create svg
        var svg = d3.select("body")
            .append("svg")
            .attr("id", "choropleth")
            .attr("preserveAspectRatio", "xMinYMin meet")
            .attr("viewBox", "0 0 " + width + " " + height)
            .style("background", "#74a9cf")
            .classed("svg-content", true);
        
        // enter code to define projection and path required for Choropleth
        // For grading, set the name of functions for projection and path as "projection" and "path"
        var projection = d3.geoNaturalEarth1().translate([width/2, height/2]).scale(245);
        var path = d3.geoPath().projection(projection);

        // define any other global variables 
        var worldmap = d3.json("world_countries.json");
        var ratings = d3.dsv(",", "ratings-by-country.csv");
        // console.log(worldmap)
        // console.log(ratings)

        Promise.all([
            // worldmap.then(function(value) {return [value]})
            // enter code to read files
            worldmap, ratings
        ]).then(response => {
            // enter code to call ready() with required arguments
            ready(this.error, response[0], response[1])
        }
        );
        
        // this function should be called once the data from files have been read
        // world: topojson from world_countries.json
        // gameData: data from ratings-by-country.csv
        
        function ready(error, world, gameData) {
            if (error) throw error;
            // enter code to extract all unique games from gameData
            const uniqueGames = [];
            for (var i = 0; i < gameData.length; i++) {
                if (uniqueGames.indexOf(gameData[i].Game) === -1) {
                    uniqueGames.push(gameData[i].Game);
                }
            }

            // Sort the game list by alphabetical order, case sensitive
            uniqueGames.sort();

            // enter code to append the game options to the dropdown
            drop = d3.select("#gameDropdown")
                .selectAll("option")
                .data(uniqueGames)
                .enter()
                .append("option")
                .attr("value", function (option) {return option})
                .text(function(option) {return option});

            d3.select("#gameDropdown").on("change", function() {
                var selection = d3.select(this).property("value");
                // console.log(selection)
                var dataForInput = gameData.filter(function(d) { return d.Game === selection})

                // Remove the current graph
                var child = document.getElementById("countries");
                var parent = document.getElementById("choropleth")
                parent.removeChild(child)

                // Create a new graph
                createMapAndLegend(world, dataForInput, selection)
            });

            selection = uniqueGames[0]
            var dataForInput = gameData.filter(function(d) { return d.Game === selection})
            // console.log(dataForInput)

            // create Choropleth with default option. Call createMapAndLegend() with required arguments.
            // Default is first game option. Only read once
            createMapAndLegend(world, dataForInput, selection)
        }



        // this function should create a Choropleth and legend using the world and gameData arguments for a selectedGame
        // also use this function to update Choropleth and legend when a different game is selected from the dropdown
        function createMapAndLegend(world, gameData, selectedGame){ 
            console.log(selectedGame)
            // fill attribute will change with gameData... gameData will change with dropdown changing! Should be input as set of data that 
            // countries w/o games are colored grey. Maybe make this default background?
            
            // Grab all current Average Values from passed in game
            const vals = [];
            for (var i = 0; i < gameData.length; i++) {
                vals.push(parseFloat(gameData[i]["Average Rating"]))
            }

            for (var i = 0; i < world.features.length; i++) {
                for (var j = 0; j < gameData.length; j++) {
                    if (world.features[i].properties.name == gameData[j].Country) {
                        world.features[i]["value"] = parseFloat(gameData[j]["Average Rating"]);
                        world.features[i]["users"] = parseInt(gameData[j]["Number of Users"]);
                        break
                    }
                }
            }
            // console.log(world.features.length)
            // console.log(world.features)
            // console.log(gameData)

            // world.features[i].properties.name -> returns name for each country
            // Add a new dictionary item for each array index
            // Struct rn is ARRAY (of 177 dictionaries) -> dictionary (geometry, id, properties, type)
            // console.log(world.features.geometry.name)
            console.log(gameData)
            
            // Create a Quantile Scale
            quantile = d3.scaleQuantile()
                .domain(vals)
                .range(["#fee0d2", "#fc9272", "#cb181d", "#67000d"])

            // Create a Quantized Scale
            // quantize = d3.scaleQuantize()
            //     // .domain(d3.extent(vals)) // pass only the extreme values to a scaleQuantizeâ€™s domain
            //     .domain(vals)
            //     .range(["#fee5d9", "#fcae91", "#fb6a4a", "#cb181d"])

            var x = d3.scaleQuantile()
                .domain([d3.min(vals), d3.max(vals)])
                .range([0, 420]);

            var tooltip = d3.select("#tooltip")
                // .attr("id", "tooltip")
                .style("position", "absolute")
                .style("visibility", "hidden")

            g = svg.append("g")
                .attr("id", "countries")
                .selectAll("path")
                .data(world.features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("fill", function (d) {
                    // console.log(d.value==undefined)
                    if (d.value != undefined) {
                        return quantile(d.value);
                    } else {
                        return "grey";
                    }
                    // return quantile(d.value)
                })
                .on("mouseover", function(){return tooltip.style("visibility", "visible");})
                .on("mousemove", function(d) {
                    var rating;
                    if (d["value"] == undefined) {
                        rating = "N/A";
                    } else {
                        rating = d["value"];
                    }

                    var users;
                    if (d["users"] == undefined) {
                        users = "N/A";
                    } else {
                        users = d["users"];
                    }

                    tooltip.html("Country: " + d["properties"]["name"]
                        + "<br> Game: " + selectedGame
                        + "<br>Avg Rating: " + rating
                        + "<br>Number of users: " + users);
                    return tooltip.style("top", (event.pageY-50)+"px").style("left",(event.pageX-175)+"px");
                })
                .on("mouseout", function(){return tooltip.style("visibility", "hidden");});

            // d3.select("#countries").data(world.features)
            //     .on("mouseover", function(){return tooltip.style("visibility", "visible");})
            //     .on("mousemove", function(){console.log(d.properties.name)})
            //     .on("mouseout", function(){return tooltip.style("visibility", "hidden");});

            // s = d3.select("svg")

            // var tooltip = d3.select("#tooltip")
            //     // .select("body")
            //     // .append("div")
            //     .style("position", "absolute")
            //     .style("z-index", "10")
            //     .style("visibility", "hidden")
            //     .style("background", "#000")
            //     .text("a simple tooltip");
            console.log(world.features)

////
                // .text("Country: " + function(d) { if (vals[0] == 7.57) { return "Yes"; } else { return "No"; }})
                // .text("Country: "
                //     + "\nGame: "
                //     + "Avg Rating: "
                //     + "Number of users: ");

            // tooltip.select("div").append("text").text("hello")

            const uniqueCont = [];
            for (var i = 0; i < world.features.length; i++) {
                uniqueCont.push(world.features[i].properties.name);
            }

            svg.append("g")
                .attr("id", "legend")
                .attr("class", "legendQuant")
                .attr("transform", "translate(" + .9*width + "," +.05*height+")")
                .attr("fill", quantile);

            var legend = d3.legendColor()
                .labelFormat(d3.format(".2f"))
                .scale(quantile);
                // .range(["#fee0d2", "#fc9272", "#cb181d", "#67000d"])

            svg.select(".legendQuant")
                .call(legend);

// .html(function (d) {return "Country: "+ d.properties.name +"<br>Game: " + selectedGame +"<br>Avg Rating: "+ function (v) {if ("value" in Object.keys(v)) { return v.value; } else { return "N/A"; }} + "<br>Number of users: " + function (u) {if ("users" in Object.keys(u)) { return u.users; } else { return "N/A"; }}});


// THIS WORKS
            // d3.select("#countries")
            //     .on("mouseover", function(){return tooltip.style("visibility", "visible");})
            //     .on("mousemove", function(){return tooltip.style("top", (event.pageY-50)+"px").style("left",(event.pageX-175)+"px");})
            //     .on("mouseout", function(){return tooltip.style("visibility", "hidden");});
//////////////

            // d3.select("body")
            //   .selectAll("div")
            //     .data(gameData)
            //   .enter().append("div")
            //     .style("width", function(d) { return x(d) + "px"; })
            //     .text(function(d) { return d; })
            //     .on("mouseover", function(d){tooltip.text(d); return tooltip.style("visibility", "visible");})
            //       .on("mousemove", function(){return tooltip.style("top", (d3.event.pageY-10)+"px").style("left",(d3.event.pageX+10)+"px");})
            //       .on("mouseout", function(){return tooltip.style("visibility", "hidden");});

            // svg.call(tip);
            // svg.selectAll("rect")
            //     .data(world.features)
            //     .enter()
            //     .append("rect")
            //     .attr("width", 100)
            //     .attr("height", 100)
            //     // .attr("y", d3.clientY)
            //     // .attr("x", d3.clientX)
            //     .on("mouseover", tip.show)
            //     .on("mouseout", tip.hide)


        }

        function handleMouseMove(e) {
            console.log("hehhehe")
            var x = d3.clientX;
            var y = d3.clientY;
            var coor = "Coordinates: (" + x + "," + y + ")";
            // document.getElementById("demo").innerHTML = coor;
        }
    </script>
    <div><text>WBoynton3</text></div>

</body>

</html>